**1014.最佳观光组合** </br>
计算数组中A[i] + A[j] + i - j的最大值 </br>
使用枚举法，分别计算A[i] + i和A[j] - j的最大值， A[i] + i在每次迭代中更新，选取j位置前所有元素的最大值，A[j] - j在每次迭代中根据计算得到。
```python
ans = -math.inf
mx = A[0] + 0
for j in range(1, len(A)):
  ans = max(ans, mx + A[j] - j)
  mx = max(mx, A[j] + j)
return ans
```

**209.长度最小的子数组** </br>
一般数组的题目求连续子数组时，采用双指针算法，本题目的双指针算法比较巧妙：</br>
1. 设置初始ans为n+1，我原本设置的是float("inf")，在最后return的时候不适合，此后遇到计算最小长度的问题时可以优化；</br>
2. 双指针start,end，首先设为0，让end先跑，跑一格，如果当前的和大于s时，start向前跑一格，减少当前和，否则就不跑；</br>
3. 当前和的计算方法不是用sum(nums[start， end])，这样会浪费大量时间，而是end每次跑时+=nums[end]，start每次跑时+=nums[start]；</br>
```python
    def minSubArrayLen(self, s: int, nums) -> int:
        """============暴力法 O(N^2) 超时============"""
        """
        if sum(nums) < s:
            return 0
        ans = float("inf")
        for i in range(len(nums)):
            for j in range(i + 1, len(nums) + 1):
                if sum(nums[i: j]) >= s:
                    if ans > j - i:
                        ans = j - i
                    else:
                        continue
        return ans
        """
        """============双指针 O(N)============"""
        if not nums:
            return 0
        n = len(nums)
        ans = n + 1
        start = 0
        end = 0
        total = 0
        while end < n:
            total += nums[end]
            while total >= s:
                ans = min(ans, end - start + 1)
                total -= nums[start]
                start += 1
            end += 1

        return 0 if ans == n + 1 else ans
```
