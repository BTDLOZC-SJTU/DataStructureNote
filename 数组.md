**1014.最佳观光组合** </br>
计算数组中A[i] + A[j] + i - j的最大值 </br>
使用枚举法，分别计算A[i] + i和A[j] - j的最大值， A[i] + i在每次迭代中更新，选取j位置前所有元素的最大值，A[j] - j在每次迭代中根据计算得到。
```python
ans = -math.inf
mx = A[0] + 0
for j in range(1, len(A)):
  ans = max(ans, mx + A[j] - j)
  mx = max(mx, A[j] + j)
return ans
```

**209.长度最小的子数组** </br>
一般数组的题目求连续子数组时，采用双指针算法，本题目的双指针算法比较巧妙：</br>
1. 设置初始ans为n+1，我原本设置的是float("inf")，在最后return的时候不适合，此后遇到计算最小长度的问题时可以优化；</br>
2. 双指针start,end，首先设为0，让end先跑，跑一格，如果当前的和大于s时，start向前跑一格，减少当前和，否则就不跑；</br>
3. 当前和的计算方法不是用sum(nums[start， end])，这样会浪费大量时间，而是end每次跑时+=nums[end]，start每次跑时+=nums[start]；</br>
```python
    def minSubArrayLen(self, s: int, nums) -> int:
        """============暴力法 O(N^2) 超时============"""
        """
        if sum(nums) < s:
            return 0
        ans = float("inf")
        for i in range(len(nums)):
            for j in range(i + 1, len(nums) + 1):
                if sum(nums[i: j]) >= s:
                    if ans > j - i:
                        ans = j - i
                    else:
                        continue
        return ans
        """
        """============双指针 O(N)============"""
        if not nums:
            return 0
        n = len(nums)
        ans = n + 1
        start = 0
        end = 0
        total = 0
        while end < n:
            total += nums[end]
            while total >= s:
                ans = min(ans, end - start + 1)
                total -= nums[start]
                start += 1
            end += 1

        return 0 if ans == n + 1 else ans
```

**215.数组中的第K个最大元素** </br>
【两行代码。。。】先对原数组排序，再返回倒数第 kk 个位置，这样平均时间复杂度是O(nlogn)
```python
    def findKthLargest(self, nums: List[int], k: int) -> int:
        nums.sort()
        return nums[-k]
```
【方法一：快速排序】
分治思想，选数组中的一个值作为标兵，比标兵小的放左边，比标兵大的放右边，递归调用即可</br>
1. 让左指针先跑，遇到比标兵大的停下；</br>
2. 看右指针的值，若小于标兵则不交换，大于则交换；</br>
3. 右指针跑，直至L==R，令list[R]=pivot。</br>
```python
def quick_sort(unsort_list: list, pre: int, post: int):
    if pre >= post:
        return

    pivot = unsort_list[pre]
    L = pre
    R = post
    while L < R:
        while L < R and unsort_list[L] < pivot:
            L += 1
        if L < R and unsort_list[R] < pivot:
            temp = unsort_list[L]
            unsort_list[L] = unsort_list[R]
            unsort_list[R] = temp

        while L < R and unsort_list[R] > pivot:
            R -= 1
        if L < R and unsort_list[L] > pivot:
            temp = unsort_list[L]
            unsort_list[L] = unsort_list[R]
            unsort_list[R] = temp

    quick_sort(unsort_list, pre, R-1)
    quick_sort(unsort_list, R+1, post)
    return unsort_list
```
不要再用temp这个lowb写法啦！！！！
```python
unsort_list[L], unsort_list[R] = unsort_list[R], unsort_list[L]
```

**718.最长重复子数组** </br>
求两个数组的最长公共子数组的长度，用暴力法的时间复杂度为$O(N^3)$，对于求公共子数组的问题，可以通过"滑动窗口"来解决，因为重复子数组在两个数组中的位置可能不同，暴力法会对两个位置重复比较很多次，因此可以进行[对齐]操作，对两个数组进行一次遍历即可。</br>
在选择初始位置时，不要A的屁股对准B的头！！！，这样会很难确定开始位置和尾部位置。只要先让A的头对准B的头，然后让A移动len(B)次，就完成了一次头到尾，再让B的头对准A的头，然后让B移动len(A)次，再完成一次头到尾，就相当于全部遍历完了。</br>
A移动时，查找的长度为min(length_a, length_b - j)，j为A已经走的距离。</br>
时间复杂度为$O((N+M)*min(N,M))$
，空间复杂度为$O(1)$
```python
    def findLength(self, A, B):
        def helper(a_start, b_start, length):
            ans = temp = 0
            for i in range(length):
                if A[a_start + i] == B[b_start + i]:
                    temp += 1
                    ans = max(ans, temp)
                else:
                    temp = 0
            return ans

        length_a = len(A)
        length_b = len(B)
        ans = 0
        for i in range(length_a):
            length = min(length_b, length_a - i)
            ans = max(ans, helper(i, 0, length))
        for j in range(length_b):
            length = min(length_a, length_b - j)
            ans = max(ans, helper(0, j, length))
        return ans
```
