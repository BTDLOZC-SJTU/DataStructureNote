**1014.最佳观光组合** </br>
计算数组中A[i] + A[j] + i - j的最大值 </br>
使用枚举法，分别计算A[i] + i和A[j] - j的最大值， A[i] + i在每次迭代中更新，选取j位置前所有元素的最大值，A[j] - j在每次迭代中根据计算得到。
```python
ans = -math.inf
mx = A[0] + 0
for j in range(1, len(A)):
  ans = max(ans, mx + A[j] - j)
  mx = max(mx, A[j] + j)
return ans
```

**209.长度最小的子数组** </br>
一般数组的题目求连续子数组时，采用双指针算法，本题目的双指针算法比较巧妙：</br>
1. 设置初始ans为n+1，我原本设置的是float("inf")，在最后return的时候不适合，此后遇到计算最小长度的问题时可以优化；</br>
2. 双指针start,end，首先设为0，让end先跑，跑一格，如果当前的和大于s时，start向前跑一格，减少当前和，否则就不跑；</br>
3. 当前和的计算方法不是用sum(nums[start， end])，这样会浪费大量时间，而是end每次跑时+=nums[end]，start每次跑时+=nums[start]；</br>
```python
    def minSubArrayLen(self, s: int, nums) -> int:
        """============暴力法 O(N^2) 超时============"""
        """
        if sum(nums) < s:
            return 0
        ans = float("inf")
        for i in range(len(nums)):
            for j in range(i + 1, len(nums) + 1):
                if sum(nums[i: j]) >= s:
                    if ans > j - i:
                        ans = j - i
                    else:
                        continue
        return ans
        """
        """============双指针 O(N)============"""
        if not nums:
            return 0
        n = len(nums)
        ans = n + 1
        start = 0
        end = 0
        total = 0
        while end < n:
            total += nums[end]
            while total >= s:
                ans = min(ans, end - start + 1)
                total -= nums[start]
                start += 1
            end += 1

        return 0 if ans == n + 1 else ans
```

**215.数组中的第K个最大元素** </br>
【两行代码。。。】先对原数组排序，再返回倒数第 kk 个位置，这样平均时间复杂度是O(nlogn)
```python
    def findKthLargest(self, nums: List[int], k: int) -> int:
        nums.sort()
        return nums[-k]
```
【方法一：快速排序】
分治思想，选数组中的一个值作为标兵，比标兵小的放左边，比标兵大的放右边，递归调用即可</br>
1. 让左指针先跑，遇到比标兵大的停下；</br>
2. 看右指针的值，若小于标兵则不交换，大于则交换；</br>
3. 右指针跑，直至L==R，令list[R]=pivot。</br>
```python
def quick_sort(unsort_list: list, pre: int, post: int):
    if pre >= post:
        return

    pivot = unsort_list[pre]
    L = pre
    R = post
    while L < R:
        while L < R and unsort_list[L] < pivot:
            L += 1
        if L < R and unsort_list[R] < pivot:
            temp = unsort_list[L]
            unsort_list[L] = unsort_list[R]
            unsort_list[R] = temp

        while L < R and unsort_list[R] > pivot:
            R -= 1
        if L < R and unsort_list[L] > pivot:
            temp = unsort_list[L]
            unsort_list[L] = unsort_list[R]
            unsort_list[R] = temp

    quick_sort(unsort_list, pre, R-1)
    quick_sort(unsort_list, R+1, post)
    return unsort_list
```
不要再用temp这个lowb写法啦！！！！
```python
unsort_list[L], unsort_list[R] = unsort_list[R], unsort_list[L]
```

**718.最长重复子数组** </br>
求两个数组的最长公共子数组的长度，用暴力法的时间复杂度为$O(N^3)$
